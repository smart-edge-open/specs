// SPDX-License-Identifier: Apache-2.0
// Copyright (c) 2019 Intel Corporation

syntax = "proto3";

package openness.eva;
option go_package = "github.com/smart-edge-open/eva";

import "google/protobuf/empty.proto";

// The services below are for calls from the controller to an edge node and so
// do not include the /devices/{id} prefix in the URL since the edge node is
// already known.

// ApplicationDeploymentService manages application deployments for an appliance.
service ApplicationDeploymentService {
    rpc DeployContainer (Application) returns (google.protobuf.Empty) {}
    rpc DeployVM (Application) returns (google.protobuf.Empty) {}
    rpc Redeploy (Application) returns (google.protobuf.Empty) {}
    rpc Undeploy (ApplicationID) returns (google.protobuf.Empty) {}
}

// ApplicationLifecycleService manages application lifecycles for an appliance.
service ApplicationLifecycleService {
    rpc Start (LifecycleCommand) returns (google.protobuf.Empty) {}
    rpc Stop (LifecycleCommand) returns (google.protobuf.Empty) {}
    rpc Restart (LifecycleCommand) returns (google.protobuf.Empty) {}
    rpc GetStatus (ApplicationID) returns (LifecycleStatus) {}
}

// Application message - contains information about the application we're about
// to deploy (or one already deployed).
//
// Image sources will be added over time. For example, pulling from external
// Docker registries may be supported with a source such as:
//
//    // Image will be downloaded from a Harbor registry
//    message DockerRegistrySource {
//        string repo = 1;
//        string tag = 2;
//
//        // authentication
//        string user = 3;
//        string token = 4;
//    }
//
// And then adding to the source field:
//
//     oneof source {
//         ...
//         DockerRegistrySource docker_registry = 9 + N;
//     }
message Application {
    string id = 1;          // unique ID generated by Controller
    string name = 2;        // name identifying the application
    string version = 3;     // release version of the application
    string vendor = 4;      // owner of the application
    string description = 5; // helpful description of the application
    int32 cores = 6;        // cores to start the application with (ignored if externally orchestrated)
    int32 memory = 7;       // memory (in MB) to reserve/allow the application (ignored if externally orchestrated)
    repeated PortProto ports = 8; // ports and protocols that the service listens on (for port exposing)

    LifecycleStatus.Status status = 9; // read only

    // Image will be downloaded from an HTTP GET endpoint
    message HTTPSource {
        // Location of VM image or container tarball. In the case of a
        // container, it will be imported with:
        //
        //     docker import ${app.source.uri} ${app.id}:latest
        string http_uri = 1;
    }
    // Source to retrieve the container or VM from. It is expected that more
    // sources will be added over time.
    oneof source {
        HTTPSource http_uri = 10;
    }

    // This contains a specification of the EAC features that this application wants.
    // (Enhanced App Configuration). This is in Json format - but is at top level
    // an array of string key-value pairs. Specific keys are defined by their respective features.
    string EACJsonBlob = 11;

    // CNI configuration for the application
    CNIConfiguration cniConf = 12;
}

// CNIConfiguration stores CNI configuration data.
// CNI specification is available at https://github.com/containernetworking/cni/blob/master/SPEC.md
message CNIConfiguration {
    string cniConfig = 1;     // CNI configuration in form of a JSON
    string interfaceName = 2; // Name of the interface
    string path = 3;          // CNI's path
    string args = 4;          // CNI's extra args passed as a CNI_ARGS env variable
}

message ApplicationID {
    string id = 1;
}

message Applications {
    repeated Application applications = 1;
}

// PortProto defines a port and protocol tuple (used for apps & VNFs)
message PortProto {
    uint32 port = 1;
    string protocol = 2;
}

message LifecycleCommand {
    string id = 1;
    enum Command {
        START = 0;
        STOP = 1;
        RESTART = 2;
    }
    Command cmd = 2;
}

message LifecycleStatus {
    enum Status {
        UNKNOWN = 0;
        DEPLOYING = 1;
        READY = 2;
        STARTING = 3;
        RUNNING = 4;
        STOPPING = 5;
        STOPPED = 6;
        ERROR = 7;
    }
    Status status = 1;
}

// The services below are for calls from an edge node to the controller.

// The Controller Virtualization Agent has endpoints for requesting information
// on virtualized (VM/container) application state managed by an external
// orchestrator.
service ControllerVirtualizationAgent {
    // GetContainerByIP queries an external orchestrator (e.g. Kubernetes) for
    // an application running (not stopped) on the Node making the request with
    // a given (active) Pod IP address. The identity of the Node making the
    // request is determined by the TLS certificate it presents at transport
    // authentication time.
    rpc GetContainerByIP (ContainerIP) returns (ContainerInfo) {}
}

message ContainerIP {
    string ip = 1;
}

// ContainerInfo represents the state of a running application.
message ContainerInfo {
    string id = 1; // the deployment ID of the application
}
